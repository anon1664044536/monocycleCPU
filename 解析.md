​              

## 单周期CPU设计实验阶段一

### 一、实验目的和要求

#### 1.实验目的

- 理解并掌握单周期CPU的设计原理和实现方法。
- 熟悉基于Verilog的硬件设计与验证流程。
- 实现基本指令的解码与执行过程，完成单周期CPU的功能性验证。

#### 2.实验要求

- 完善一个单周期LA32 CPU设计
- 支持`add.w`、`addi.w`、`ld.w`、`st.w`和bne指令功能
- 最终远程上板测试通过

### 二、实验原理,逻辑框图和实验设备

#### 1.实验原理

**单周期CPU结构简介**

- **指令存储**：用于存放执行指令的存储器（`inst_sram`）。
- **数据存储**：用于加载/存储数据的存储器（`data_sram`）。
- **程序计数器（PC）**：保存下一条指令地址的寄存器。
- **控制单元**：生成控制信号以协调CPU模块的操作。
- **ALU（算术逻辑单元）**：执行算术和逻辑运算。

**主要模块说明**

- **PC寄存器**：保存当前指令的地址，并生成下一条指令地址。
- **指令解码器**：将指令划分为操作码和操作数，并生成控制信号。
- **寄存器文件**：存储32位寄存器，提供读写接口。
- **控制逻辑**：根据指令操作码生成控制信号，如寄存器写使能、内存写使能等。
- **ALU**：完成算术运算与逻辑运算。

**指令集支持**
支持以下指令：

- `add_w`：寄存器间加法。
- `addi_w`：立即数加法。
- `ld_w`：从内存加载数据。
- `st_w`：向内存存储数据。
- `bne`：条件跳转。

#### 2.逻辑框图

![逻辑框图1](.\picSrc\逻辑框图1.png)

#### 3.实验设备

配有Vivado环境的主机

### 三、实验内容

**1.CPU设计**

- 根据实验要求，完成以下模块的Verilog代码实现：
  - **指令存储与程序计数器**：实现指令的存取和PC的更新逻辑和跳转地址计算功能。
  - **指令解码与控制逻辑**：解码操作码并生成相应的控制信号。
  - **寄存器文件**：实现32位宽的寄存器读写功能。
  - **ALU**：实现加法运算

**2.功能验证**

- 编写测试用例，验证CPU对以下指令的正确执行：
  - 加法指令（`add_w`）。
  - 立即数加法（`addi_w`）。
  - 加载/存储指令（`ld_w`，`st_w`）。
  - 条件跳转（`bne`）。

**3.仿真与调试**

- 对发现的设计问题进行修正，确保所有指令均正确执行。

## 单周期CPU设计实验阶段二

### 一、实验目的和要求

#### 1.实验目的

- 掌握单周期CPU的设计与实现方法，理解其工作原理和结构组成。
- 实现基本指令集的单周期执行，包括算术运算、逻辑运算、数据加载与存储，以及分支跳转等指令。
- 掌握CPU设计中的控制信号生成及数据路径设计。

#### 2.实验要求

- 设计并实现支持基本指令集的单周期CPU，包括`add`、`sub`、`and`、`or`、`lw`、`sw`、`beq`等指令。
- 完成实验代码的编写、仿真和调试，确保指令执行的正确性。
- 输出关键调试信息，包括当前指令、PC值、寄存器值和内存读写数据。

### 二、实验原理,逻辑框图和实验设备

#### 1.实验原理

**数据路径设计：**
数据路径包括指令存储器、数据存储器、寄存器堆、ALU和相关多路选择器，用于实现指令的执行。

**控制信号生成：**
通过控制单元对输入指令进行译码，生成控制信号，指导数据路径各模块完成任务。

**指令执行流程：**

- **取指阶段：** 从指令存储器读取指令。
- **指令译码：** 解析指令操作码及操作数。
- **执行阶段：** 根据指令类型在ALU中完成算术运算或逻辑运算，或计算目标地址。
- **内存访问阶段：** 根据指令需求访问数据存储器。
- **写回阶段：** 将运算结果写回寄存器堆。

**关键模块：**

**ALU：** 完成算术运算和逻辑运算。

**寄存器堆：** 提供数据存储和快速访问的寄存器文件。

**存储器接口：** 用于加载和存储数据。

**控制单元：** 根据指令生成控制信号，协调CPU各模块的工作。

#### 2.逻辑框图

![逻辑框图2](.\picSrc\逻辑框图2.png)

#### 3.实验设备

配有Vivado环境的主机

### 三、实验内容

**指令集设计：**
实现以下基本指令：

- 算术运算：`add`, `addi`, `sub`
- 逻辑运算：`and`, `or`, `xor`, `nor`
- 数据加载与存储：`lw`, `sw`
- 分支跳转：`beq`, `bne`, `b`, `bl`,`jirl`

**模块化设计：**

- **控制单元：** 实现指令译码逻辑。
- **数据路径：** 搭建CPU的数据路径，包括PC寄存器、ALU、寄存器堆等。

**代码实现：**
使用Verilog描述单周期CPU的硬件电路。

**功能验证：**

- 编写测试程序验证CPU正确性，例如：
  - 加法和减法运算。
  - 逻辑运算的正确性。
  - 加载与存储指令对数据存储器的访问。
  - 条件分支的跳转行为。
- 进行功能仿真，观察CPU的执行情况。

## 单周期CPU设计实验阶段一

### 一、实验过程截图，实验步骤介绍和实验结果截图

#### 1.实验过程截图

![实验1代码](.\picSrc\实验1代码.png)

#### 2.实验步骤介绍

**模块分析**

- 仔细阅读 `minicpu_top` 代码，明确各信号的意义和用途。
- 分析模块间的交互逻辑，包括 `inst_sram` 和 `data_sram` 的读写过程。

**仿真运行**

- 监测程序计数器 `pc`。
- 验证 `alu_result` 的正确性。
- 检查分支跳转逻辑 `br_taken` 和 `nextpc` 的结果。
- 验证内存读写和寄存器更新是否正确。

**功能测试**

- 编写简单指令序列，验证以下功能：
  - 算术指令（`add_w` 和 `addi_w`）
  - 数据访问指令（`ld_w` 和 `st_w`）
  - 分支指令（`bne`）
- 根据预期结果与实际仿真结果对比，判断模块功能实现是否正确。

#### 3.实验结果截图

![实验结果1](.\picSrc\实验结果1.png)

### 二、实验结果与分析

led和switch均为阴极二极管, 所以1代表0, 0代表1, 需要对每位进行取反操作。

`f7`为`1111` `0111`, 取反之后为`0000` `1000`, 为十进制数的8, 说明led对应的值应该为斐波那契数列的第8位, 即34。

`ffdd`为`1111` `1111` `1101` `1101`, 取反之后为`0000` `0000` `0010` `0010`,为十进制数的34, 正好对应斐波那契数列的第8位。

## 单周期CPU设计实验阶段二

### 一、实验过程截图，实验步骤介绍和实验结果截图

#### 1.实验过程截图

![实验2代码](.\picSrc\实验2代码.png)

![alu](.\picSrc\alu.png)

#### 2.实验步骤介绍

### **a. 理解CPU模块架构**

- 熟悉`mycpu_top`模块的整体设计框架，包括：

  * 指令存储器、数据存储器和调试接口的连接。

  - 各种控制信号的生成与使用。

- 分析指令的操作码字段及其对应的功能定义。

### **b. 实现并验证各个子模块**

#### **（1）ALU模块的实现**

实现`alu`模块，完成以下功能：

- 基本算术运算：加法、减法。
- 逻辑运算：与、或、异或、非。
- 位移运算：逻辑左移、逻辑右移、算术右移。
- 比较运算：有符号和无符号比较。

为`alu`模块提供测试用例，验证各运算功能是否正确。

#### **（2）立即数生成模块的实现**

- 根据不同指令类型，提取并扩展对应的立即数。
- 验证各种立即数生成逻辑是否正确。

### **c. 实现调试功能与仿真**

通过`debug_wb_pc`、`debug_wb_rf_wen`、`debug_wb_rf_wnum`、`debug_wb_rf_wdata`信号输出关键调试信息。

确保调试接口能够正确反映寄存器写回的内容和当前指令地址。

与参考CPU的输出值进行比对, 找出错误所在。

#### 3. 实验结果截图

![实验结果2](.\picSrc\实验结果2.png)

### 二、实验结果与分析

#### 1. 指令

* **计算指令**

``` verilog
rd, rj, rk GR[rd] = GR[rj] + RG[rk]
addi rd, rj, si12 GR[rd] = GR[rj] + sext32(si12)
sub rd, rj, rk GR[rd] = GR[rj] - RG[rk]
slt rd, rj, rk GR[rd] = GR[rj] < RG[rk] //signed
sltu rd, rj, rk GR[rd] = GR[rj] < RG[rk] //unsigned
slli rd, rj, ui5 GR[rd] = GR[rj] << ui5
srli rd, rj, ui5 GR[rd] = GR[rj] >> ui5 //logic
srai rd, rj, ui5 GR[rd] = GR[rj] >> ui5 //arith
and rd, rj, rk GR[rd] = GR[rj] && RG[rk]
or rd, rj, rk GR[rd] = GR[rj] || RG[rk]
nor rd, rj, rk GR[rd] = ~(GR[rj] || RG[rk])
xor rd, rj, rk GR[rd] = GR[rj] ^ RG[rk]
lu12i rd, si20 GR[rd] = {si20, 12'b0}
```

* **内存指令**

``` verilog
ld rd, rj, si12 GR[rd] = MEM(GR[rj] + sext32(si12))[31:0]
st rd, rj, si12 MEM(GR[rj] + sext32(si12))[31:0] = GR[rd][31:0]
```

* **跳转指令**

``` verilog
bne rj, rd, offs16 if(GR[rj] != GR[rd]) PC = PC + sext32({off16,2'b00})
beq rj, rd, offs16 if(GR[rj] == GR[rd]) PC = PC + sext32({off16,2'b00})
b offs26 PC = PC + sext32({off26,2'b00})
bl offs26 GR[1] = PC + 4; PC = PC + sext32({off26, 2b'0})
jirl rd, rj, offs16 GR[rd] = PC + 4; PC = GR[rj] + sext32({offs16, 2b'0})
```



#### 2. 控制信号

##### 1.src1_is_pc

操作数1为PC
把PC送往ALU，完成在寄存器中存储的功能(GR = PC + 4)
`inst_b1` | `inst_jirl`

##### 2.src2_is_imm

操作数2为立即数
先判断是否为立即数，后续再进行为多少位立即数的逻辑判断

- **计算指令:** `inst_addi_w` , `inst_slli_w` , `inst_srli_w` , `inst_srai_w` , `inst_lu12i`
- **内存指令:** `inst_ld_w` , `inst_st_w`
- **跳转指令:** `inst_bl` , `inst_jirl`

只有`bl` 和`jir` 指令的PC才需要往ALU里送，所以他们才需要立即数，别的都是送往`MUX2`

##### 3.res_from_mem

- **第一个结果:** ALU 的数据
- **第二个结果:** ALU 的结果作为地址,送到内存里读的数据

判断是否为第二个结果
`inst_ld`

##### 4.gr_we

是否往寄存器写数据
除了`inst_bne` , `inst_beq` , `inst_b` , `inst_st_w` 这四条指令,别的都有寄存器的写
所以逻辑为

``` verilog
assign gr_we = ~inst_bne & ~inst_beq & ~1 inst_b & ~inst_st_w
```

##### 5.mem_we

是否往内存中写数据

`inst_st_w`

##### 6.src_reg_is_rd

判断rd 是否为源操作数, 往寄存器的RA2 送, 从RD2 中读出数据

- **内存指令:** `inst_st_w`
- **跳转指令:** `inst_beq` `inst_bne`

这两条跳转指令需要GR[rd] , 来进行逻辑判断, 所以也需要把数据读出来

##### 7.rg_waddr_is_1

判断写寄存器的地址是否为`1`,还是为`rd`
`inst_b1`

##### 8.立即数判断

**scr2的立即数**

``` verilog
assign need_ui5 = inst_slli_w | inst_srli_w | inst_srai_w;
assign need_si12 = inst_addi_w | inst_ld_w | inst_st_w;
assign need_si20 = inst_lu12i;
assign src2_is_4 = src1_is_pc;
```

**跳转指令的偏移值**

``` verilog
assign need_si16 = inst_beq | inst_bne | inst_jirl;
assign need_si26 = inst_b | inst_bl;
```

##### 9.br_taken

PC是加上偏移量还是正常+4

``` verilog
assign br_taken = valid & (
(inst_beq & rj_eq_rd) ||
(inst_bne & ~rj_eq_rd) ||
inst_b ||
inst_bl ||
inst_jirl );
```

##### 10.br_target_is_pc_add_offs

是PC的值加上偏移量还是`RG[rj]`

``` verilog
assign br_target_is_pc_add_offs = inst_beq || inst_bne || 1 inst_bl || inst_b;
```

##### 11.PC计算的偏移值

共有两个立即数
`si16_32` , `si26_32`

``` verilog
assign si16_32 = {{14{i16[15]}},i16,2'b00};
assign si26_32 = {{4{i26[25]}},i26,2'b00};
assign br_offs = (
(si16_32 & {32{need_si16}}) |
(si26_32 & {32{need_si26}})
);
```

##### 12.ALU计算的立即数

共有四个立即数
`ui5` , `si12` , `si20` , `4`

``` verilog
assign ui5_32 = rk;
assign si12_32 = {{20{i12[11]}},i12[11:0]};
assign si20_32 = {i20[19:0],12'b0};
assign si4_32 = 32'h04; //把十进制的4扩展到32位
assign imm = (
(ui5_32 & {32{need_ui5}}) |
(si12_32 & {32{need_si12}}) |
(si20_32 & {32{need_si20}}) |
(si4_32 & {32{src2_is_4}})
);
```

